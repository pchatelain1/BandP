(!**************************************************************************
   A working Branch & Price algorithm
   ======================

   file BranchAnsPrice.mos
   ```````````````
   TYPE:         Branch-and-Price for @@@@@@@@@

   FEATURES:     mmjobs, Mosel 2.0 records.
   DESCRIPTION:  @@@@@@@@  A set of production batches is assigned to machines with the
                 objective to maximize profit. The model implements a branch-
                 and-price algorithm that solves a disaggregated formulation of
                 the GAP where columns represent feasible assignments of batches
                 to machines. Column generation is applied at every node of the
                 branch-and-bound tree. Branching is based on fixing compact
                 formulation variables that represent assignments of production
                 batches to machines. The branch-and-bound logic is
                 implemented in Mosel, and the optimizer is used only to solve
                 the LP relaxation at each node.

   FURTHER INFO:
       author: Paul Chatelain (2020) - paul.chatelain.at.uclouvain.be


       STABLE
***************************************************************************!)


model GAPmas
    uses "mmxprs", "mmjobs", "mmsystem", "mmsheet"


    parameters
        TOL = 0.00001
        DO_BRANCHING=true
        DO_HEURISTIC=false
        CUTOFF=1000000
        BRANCH_STRATEGY=0                                                   ! 0 is for variable branching (this is a placeholder for other branching strategies)

        BIG=1000000
        SUBMOD="GAPsubDP5-3.mos"                                              ! This mosel file contains the pricing problem
        MESSLEV=4                                                           ! 0: silent, 1-5: progressivly more detailed output


        DO_MIP= false
        GRID=9
        INITIAL_COL= 6
        MAXPATH = 4

    end-parameters


(!**************************************************************************
    Parameter and data initialiations:
        GS: Size of the grid
        NbP: Number of path
        NbF: Number of flights
        NbN: Number of Nodes in the grid
        NbA: Nmber of Arcs in the grid
        NbZ: Number of Zones in the grid
        NL: Number of Layer in the grid
        NC: Node center (starting node) in the grid
        SN: Sink node in the grid

        Params2.dat is the file that contains all the information

        Some general parameters are initialized in section "parameters"

****************************************************************************!)


    SOURCE_PATH := "Size"+GRID+"/rand/"
    if DO_MIP = true then

        OUTPUT := "out v1 MIP TEST.txt"
    else
        OUTPUT := "out v1 NO MIP TEST.txt"
    end-if

    declarations
     GS,NbP,NbF,NbN, NbA,NbZ, NL, NC,SN: integer
    end-declarations



    fopen(SOURCE_PATH+"Params2.dat",F_INPUT)                                            ! Open the file F for reading
    !fopen(SOURCE_PATH+OUTPUT,F_OUTPUT)
    writeln("Reading file `","Params2.dat","'...")
    readln(GS,NbP,NbF,NbN, NbA,NbZ, NL, NC,SN)



    setparam("XPRS_PRESOLVE",0)

    declarations
        EVENT_GEN_INI_COLS=2        ! Event codes sent to submodels
        EVENT_GEN_COLS=3
        EVENT_STOP_SUBMOD=5
        EVENT_NEW_NODE=9

        EVENT_SOLVED=6              ! Event codes sent by submodels
        EVENT_FAILED=7
        EVENT_READY=8
        EVENT_INFEAS=11
    end-declarations


    declarations
    !SETS
    Ini_Paths= 1..INITIAL_COL
    Paths: range
    Flights= 1..NbF
    Nodes= 1..SN
    Arcs= 1..NbA
    Zones= 1..NbZ


    !DATA

    WeightZone:  array(Zones) of integer
    ArcCap: array(Arcs) of real
    Successor:  array(Nodes) of list of integer
    Predecessor: array(Nodes) of list of integer
    ImpactMatrix: array(Flights) of array(Arcs) of dynamic array(1..2) of array(1..2) of integer
    ArrivalNodeList: array(Arcs) of integer
    ArcWeight: array(Flights) of array(Arcs) of integer

    end-declarations



    !Loading the data

      initializations from SOURCE_PATH+"ArcCap.dat"         ArcCap as "ArcCap"                  end-initializations
      initializations from SOURCE_PATH+"Predecessor2.dat"   Predecessor as "Predecessor"        end-initializations
      initializations from SOURCE_PATH+"Successor2.dat"     Successor as "Successor"            end-initializations
      initializations from SOURCE_PATH+"ArrivalNode.dat"    ArrivalNodeList as "ArrivalNode"    end-initializations
      initializations from SOURCE_PATH+"ImpactMat2.dat"     ArcWeight as "ImpactMat2"           end-initializations




    !Make data available for submodels (pricing problem) to read
    initializations to "bin:shmem:data"
     ArcWeight
     Successor
     Predecessor
     ArcCap
     ArrivalNodeList
    end-initializations



(!*************************************************************************
**********************  Branch-and-Price Declarations  ********************
*************************************************************************!)

    declarations

      Master_flowPath:  array(Flights, Paths) of mpvar                  ! Variable of the RMP (Restricted Master Problem) (x_l,j) i.e. if weight of each column.
      Master_pathSelect: array(Paths) of mpvar                          ! Variable of the RMP. =1 of path k is selected, 0 otherwise. (y^j)
      Master_arcSelect: array(Arcs) of mpvar                            ! Variable of the RMP. We will branch on this variables. It represents the arcs (z_e)

      Master_FlowMin: linctr                                            ! Objective function of the RMP
      Master_Cons_FlightPath: array(Flights, Paths) of linctr           ! Constraint 0 of the RMP (x_{l,j} <= y_j for all l,j)
      Master_Cons_ArcCap: array(Arcs) of linctr                         ! Constraint 1 of the RMP
      Master_MinflowCons: array(Arcs) of linctr                         ! Constraint 2 of the RMP
      Master_Cons_MaxPath: linctr                                       ! Constraint 3 of the RMP
      Master_Cons_Flow: array(Flights) of linctr                        ! Constraint 4 of the RMP
      Master_Cons_FlightPath2: array(Paths) of linctr

      PathsInArc: array(Arcs) of  list of integer                       ! Which path is going through which arc
      ArcsInPath: array(Paths) of list of integer                       ! Which arc compose a path
      ImpactPath: array(Flights) of array(Paths) of real                ! The total impact of a path
      SmallCap: array(Paths) of real                                    ! The minimal cap of the path



      Dual_sigma: array(Arcs) of real                                   ! Dual values for Master_Cons_ArcCap
      Dual_psi: array(Arcs) of real                                     ! Dual values for Master_MinflowCons
      Dual_gamma: real                                                  ! Dual value for Master_Cons_MaxPath
      Dual_lambda: array(Flights) of real                               ! Dual value for Master_Cons_Flow

     branchvartype=
        record                  ! Data structure representing compact formulation variables:
         f: integer             ! flight
         k: integer             ! path
         size: integer          ! size of the path
         path: list of integer  ! List of arc in the fixed path
         a: integer             ! First divergent arc
  end-record

      Fixed=
       record                                                           ! Data structure representing fixed variables:
         var:    branchvartype                                                ! Variable that is fixed
         to_zero: boolean                                               ! True if fixed to zero, false if fixed to one
       end-record

      fixed_vars: array(range) of Fixed                                ! Array with all fixed variables
      fixedcolumns: set of integer

      Nfixed: integer                                                   ! Number of compact formulation variables fixed
      NWfix: integer                                                    ! Count of constraints to fix variables
      consfix: array(range) of linctr                                   ! Constraints to fix variables

      Node=
        record
          value: real                                                   ! Optimal value of relaxation associated with node
          left, right, parent : integer                                 ! Pointers to parent and children in node tree
          feasible_sol: boolean
          integer_sol: boolean
          solbasis: basis                                               ! Basis associated with optimal value of relaxation
          prev_val, next_val: integer                                   ! Pointers to nodes in linked queue of active nodes (queue is maintained sorted by value)
          branchvar: branchvartype                                      ! Variable to branch at (variable branching)
          gen_path: list of integer                                     ! Path numbers generated at this node
          depth: integer                                                ! Depth of the node
          time: real                                                    ! Time when the node is solved
          num_fixed: integer                                            ! Number of variable fixed at this node
          fixed: list of integer
        end-record

      R: range
      nodes:dynamic array(R) of Node                                    ! Array containing all nodes
      node: integer                                                     ! Current node being solved by column generation
      head: integer                                                     ! Head of queue of active nodes (0 if queue is empty)
      tail: integer                                                     ! Tail of queue of active nodes (0 if queue is empty)
      Select_node:integer                                               ! Active node selected for branching

      Low_bound: array(range, 1..2) of real                             ! This table contains the lower bound by depth


      active_arc_bool: boolean
      search_div_arc: boolean
      already_fixed: boolean



      active_path: list of integer                                      ! Store the active path at a node
      non_integer_flight: list of integer
      non_integer_path: array(Flights) of list of integer
      active_arc: list of integer                                       ! Store the arc which are in an active path
      compt2: array(Flights) of integer
      compt3: array(Flights) of list of integer
      compt4: array(Paths) of integer
      arc_use: array(Arcs) of integer
      Tot_num: integer
      possible_sol: boolean
      int_FO: real
      no_new_path: boolean
      divergent_arc: list of integer

      sol_BEST: array(Flights, Paths) of real                           ! Current best feasible solutions
      sol_BEST2: array(Flights) of integer
      
      
      tot_time_pricing: real
      tot_time_heuristic_int: real
      
      


      lower_bound: real                                                 ! Lower bound from Lagrangian relaxation calculated at every iteration
      Best_low_bound: real                                              ! Best lower bound from Lagrangian relaxation
      Best_Value: real                                                  ! Incumbent value
      masbasis: basis                                                   ! Used to save basis at every column generation iteration
      Totiter: integer                                                  ! Count of column generation iterations
      number_of_path: integer                                           ! Count of columns in disaggregated formulation
      integer_solution: boolean                                         ! True if latest node solution is integer (set by translate_solution)

      first_branching: boolean

    end-declarations


(! ***************** Column Generations Procedures  ***********************!)

    forward procedure solve_node
    forward procedure process_sub_result
    forward procedure solve_master(Niter : integer)
    forward procedure process_master_result
    forward procedure integer_heurisitc
    forward procedure do_integer_flow
    forward procedure check_num_path
    forward procedure check_possible_sol


!Branch-and-Price supporting procedures
    forward procedure check_solution
    forward procedure branching_variable
    forward procedure variable_branching_reset
    forward procedure fixvar(var: branchvartype,to_zero:boolean)


!Placeholder for heuristic
    !forward procedure heuristic

!Reporting procedures
    forward procedure save_best_solution
    forward procedure print_master_solution
    !forward procedure write_sol_GAP         ! Writes node solution in terms of compact representation variables
    !forward procedure write_sol_BEST        !Writes incumbent solution in terms of compact representation variables
    forward procedure write_msg(msglevel:integer, msg:string)
    forward procedure print_status
    !forward procedure write_new_col(Path:integer)
    forward procedure do_MIP
    forward procedure find_non_integer



(! ************************************************************************
***************************************************************************
**************           Running the submodel             *****************
***************************************************************************
*************************************************************************!)

    declarations
        submod:  Model                                          !The pricing submodel
    end-declarations

    res:= compile("g", SUBMOD, "tmp:gapsub.bim")

        load(submod, "tmp:gapsub.bim")
        run(submod)
        wait
        ev:=getnextevent
        if ev.class= EVENT_END then
            writeln("*** Impossible to start all necessary models - aborting ***")
            exit(1)
        end-if


(! ************************************************************************
***************************************************************************
*******           Solve Root Node with initial columns           **********
***************************************************************************
*************************************************************************!)


! Initial Columns are provided and are not generated here. We just copy the data in the proper array

    declarations
        Ini_ArcsInPath: array(Ini_Paths) of list of integer
        Ini_ImpactPath: array(Flights) of array(Ini_Paths) of real
        Ini_SmallCap: array(Ini_Paths) of real

        obj_val: real                                                       ! Value received from the DP. Value of the objective function.
        min_cap_path: real                                                  ! Value received from the DP. Minimal cap of the new path.
        tot_impact_NP: array(Flights) of real                               ! Value received from the DP. Impact of the path for each flight.
        new_path_short: list of integer                                     ! Value received from the DP. List which contains all the arc in the path.

    end-declarations


    initializations from SOURCE_PATH+"ImpactPath.dat"   Ini_ImpactPath as "ImpactPath"    end-initializations
    !initializations from SOURCE_PATH+"SmallCap.dat"     Ini_SmallCap as "SmallCap"        end-initializations
    initializations from SOURCE_PATH+"ArcsInPath.dat"   Ini_ArcsInPath as "ArcsInPath"    end-initializations


! We copy the data of the k initials path into the array of variable length and we create the (Flights*k) corresponding variables.
    forall(j in Ini_Paths) do
        ArcsInPath(j) := Ini_ArcsInPath(j)
        SmallCap(j) :=  5
        create(Master_pathSelect(j))
        forall(i in Flights)  do
            create(Master_flowPath(i,j))
            !Master_flowPath(i,j) is_binary
            ImpactPath(i,j) := Ini_ImpactPath(i,j)*3
        end-do
    end-do

! Now based on ArcsInPath, we build the array Paths in Arcs
forall(path in Ini_Paths) do
    forall(el in ArcsInPath(path)) do
        PathsInArc(el) += [path]
    end-do
end-do

!! Ici on round les arcap... a retirer par la suite ! :)

forall(arc in Arcs) do
   ArcCap(arc) := floor(ArcCap(arc))
end-do


writeln(ArcCap)
writeln("SIZEE: ", getsize(Low_bound))

  number_of_path := INITIAL_COL            ! There are #INITIAL_COL initial paths




! Define and solve Master Model with initials columns
! *************************************************************************


    StartTime := gettime



    Master_FlowMin := sum(f in Flights, k in Paths) ImpactPath(f,k)*Master_flowPath(f, k)                                                               ! Objective function definition.


    forall(f in Flights, k in Paths) Master_Cons_FlightPath(f,k) :=  Master_flowPath(f,k) - Master_pathSelect(k)    <= 0                                 ! Constraint 0
    !forall(k in Paths) Master_Cons_FlightPath2(k) :=  sum(f in Flights) Master_flowPath(f,k)     <= Master_pathSelect(k)*SmallCap(k)                     ! Constraint 0
    forall (a in Arcs) Master_Cons_ArcCap(a) := sum(f in Flights, el in PathsInArc(a)) Master_flowPath(f,el) - ArcCap(a)*Master_arcSelect(a)  <=  0      ! Constraint 1 (44)

    !forall(a in Arcs) Master_MinflowCons(a) := sum(f in Flights, el in PathsInArc(a)) Master_flowPath(f,el) - Master_arcSelect(a)     >=   0               ! Constraint 2 (45) V1
    !forall(a in Arcs) Master_MinflowCons(a) := sum(el in PathsInArc(a)) Master_pathSelect(el) - Master_arcSelect(a)     >=   0                           ! Constraint 2 (45) V2


    Master_Cons_MaxPath := sum(k in Paths) Master_pathSelect(k) <= MAXPATH                                                                                     ! Constraint 3 (46)
    forall(f in Flights) Master_Cons_Flow(f) := sum(k in Paths) Master_flowPath(f,k) = 1                                                                 ! Constraint 4 (47)



    forall(k in Paths) Master_pathSelect(k) is_binary
    forall(a in Arcs) Master_arcSelect(a)  is_binary
    forall(f in Flights, k in Paths) Master_flowPath(f,k) is_binary


    write_msg(2, "Solving initial master problem: "+ (gettime-StartTime) + "sec")
    !exportprob(EP_MIN, "BandPrice0.txt", Master_FlowMin)

    minimize(XPRS_LIN, Master_FlowMin)
    savebasis(masbasis)

    write_msg(1, "Iter: 0  sol: " + getobjval)


    Best_Value:=CUTOFF                          ! Best_Value = CUTOFF = 1000000000

    process_master_result
    print_master_solution
    solve_node
    lower_bound := getobjval

    write_msg(2, "Solving initial relaxation of restricted master problem: "+ (gettime-StartTime) + "sec")


    if DO_MIP then
        do_MIP
    end-if

    minimize(XPRS_LIN, Master_FlowMin)
    process_master_result
    print_master_solution


    write_msg(2, "Solving First node "+ (gettime-StartTime) + "sec")



!***************************************************************************
!***************************************************************************
!***********************   Begin Branch-and-Price  *************************
!***************************************************************************
!***************************************************************************


if DO_BRANCHING then

!***************************************************************************
!********   Initialize root node in search tree active nodes  **************
!***************************************************************************

  writeln("")
  writeln("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
  write_msg(2, "Start branching: " + (gettime-StartTime) + "sec")
  node                   := 0
  NWfix                  := 0
  Nfixed                 := 0
  first_branching        := true

  check_solution

  if integer_solution then
    save_best_solution
    writeln("This is an integer feasible solution.")
  else
    writeln("This is not an integer feasible solution.")
    if BRANCH_STRATEGY=0 then
        branching_variable
    end-if
  end-if



 if getprobstat = 3 or getprobstat = 6  then
    nodes(node).feasible_sol:=false
    write_msg(1, "Infeasible")
  elif integer_solution then
    write_msg(1, "Integer Solution")
    nodes(node).integer_sol:=true
  else
    nodes(node).feasible_sol:=true
    nodes(node).integer_sol:=false
    nodes(node).value:=getobjval
    nodes(node).parent:=-1
    nodes(node).prev_val:=-1
    nodes(node).next_val:=-1
    head:=0
    tail:=0
    Select_node:=0
    nodes(node).left:= -1
    nodes(node).right:=-1
  end-if

  if nodes(0).feasible_sol and not nodes(0).integer_sol then

    writeln("Begin looping over search tree nodes...")
    search_done := false

    repeat
      node += 1                                     ! We create a new node
      nodes(node).parent:=Select_node               ! The parent node of the new node is Select_node (i.e. the previous node in the queue ?)
      nodes(node).left:= -1
      nodes(node).right:=-1





    !*****************************************************
    !** Reset the master model for the current node.
    !*****************************************************
    (!Master model columns that are fixed to zero for current node
    are first put in set fixedcolumns. Constraints consfix are
    used to fix the columns to zero. Also, information about
    fixed variables is passed to knapsack submodels.
    Procedures used:
        variable_branching_reset
        fixvar(branchvar:branchvartype,to_zero:boolean)
    Functions used (to manage set fixedcolumns):
        function encode(m:integer,k:integer):integer
        function getm(e:integer):integer
        function getk(e:integer):integer
    !)


    writeln("Nfixed value at the beginning of the loop: ", Nfixed)
    forall(c in 1..Nfixed) consfix(c) := 0                                  ! At a new node, we delete all the previous constraints to fix variable
    Nfixed:=0


    if BRANCH_STRATEGY=0 then variable_branching_reset; end-if              ! At a new node, we recreate the table of all branch


      initializations to "bin:shmem:fixed"
        Nfixed
        fixed_vars
        ArcsInPath
      end-initializations


    !writeln("NFIXED : ", Nfixed)
    !writeln("FIXED VAR TABLE: ", fixed_vars)
    writeln("Nfixed value after Branching Reset: ", Nfixed)
    nodes(node).num_fixed := Nfixed
    forall(c in 1..Nfixed) do                                               ! Pour tous les arcs qui ont étés fixés : 1 à nombre d'arc fixés.
        if fixed_vars(c).to_zero = true then                                ! Si il est fixé à 0 alors.
            writeln("FIXED VARS to zero: ", fixed_vars(c).var)
            consfix(c):= Master_flowPath(fixed_vars(c).var.f,fixed_vars(c).var.k ) = 0            ! On ajoute le contrainte -> ceci interdit tous les chemins qui passent par cet arc.
        else
            writeln("FIXED VARS to One: ", fixed_vars(c).var)
            consfix(c):= Master_flowPath(fixed_vars(c).var.f,fixed_vars(c).var.k ) = 1            ! On ajoute le contrainte -> ceci interdit tous les chemins qui passent par cet arc.
        end-if
    end-do



    send(submod, EVENT_NEW_NODE, 0)                                         ! We ask the pricing to update himself with the branching



    !*****************************************************
    !** Optimize Master (OK)
    !*****************************************************

      loadprob(Master_FlowMin)                          ! Reload the problem
      loadbasis(nodes(Select_node).solbasis)            ! Load saved basis


     writeln("")
     writeln(" Solving the RMP after the branching...")
      minimize(XPRS_LIN,Master_FlowMin)
      print_status

     print_master_solution

    savebasis(masbasis)

      process_master_result
      solve_node
      check_solution

      if not integer_solution then
      writeln("Update search tree based on solution of current node")
    !Determine how to branch off the current node        active nodes
        if (BRANCH_STRATEGY=0) then  branching_variable; end-if
      end-if


    !*****************************************************
    !** Update search tree based on solution of current node
    !**(Update status of all nodes using new information)
    !*****************************************************

    if getprobstat = 3 or getprobstat = 6  then
        nodes(node).feasible_sol:=false
        write_msg(3, "Infeasible")
    else
        nodes(node).feasible_sol:=true
        nodes(node).value:= getobjval      !!! Attention ici il met best low bound
        savebasis(nodes(node).solbasis)

        if integer_solution then                                                    ! Si on trouve une solution entière...
            write_msg(2, "Integer Solution Found")
            nodes(node).value:=getobjval
            nodes(node).integer_sol:=true
            if nodes(node).value<Best_Value then                                    ! Et si cette solution est meilleur que la précédente...
                save_best_solution                                                  ! On sauvegarde la solution
                Best_Value:=nodes(node).value                                       ! On update la Best-Value
                write_msg(2, "Improved integer value: " + Best_Value)
                 if head=-1 or Best_Value - nodes(head).value < 1.0 then
                    writeln("Le noeud ", node, " ne va pas améliorer la solution... Value: ", nodes(head).value)
                    search_done:=true
                end-if
            end-if

        else                                                                    ! Current node become active in the three
                if nodes(node).value <= Best_Value - 0.000001 then
                    position:= head
                    !Tail
                    repeat
                      if position<>-1 and nodes(node).value >= nodes(position).value  then
                        position:=nodes(position).next_val
                      else
                        !p1 will precede node and position will follow
                        !p1 --- node --- position
                        if position<>-1 then
                          p1:=nodes(position).prev_val
                          nodes(position).prev_val:=node
                        else
                          p1:=tail
                          tail:=node
                        end-if
                        if p1<>-1 then
                          nodes(p1).next_val:=node
                        else
                          head:=node
                        end-if

                        nodes(node).prev_val:=p1
                        nodes(node).next_val:=position

                       break
                      end-if
                    until false
                else
                    write_msg(3,"Cutoff node: " + node)
                end-if
            end-if
        end-if



    Low_bound(Nfixed,1) += 1
    writeln("SIZZE 2: ", getsize(Low_bound))
    if Low_bound(Nfixed,1) = 1 then
        Low_bound(Nfixed,2) := 100000
    end-if
    if Low_bound(Nfixed,2) > nodes(node).value then
        Low_bound(Nfixed,2) := nodes(node).value
    end-if
    if Low_bound(Nfixed,1) = 2^Nfixed then
        writeln("ON TERMINE LA COLONNE LÔ")
        lower_bound := Low_bound(Nfixed,2)
    end-if

    writeln("TEST LÔ: ", Low_bound(Nfixed,1), "ICI LÔ: ", Low_bound(Nfixed,2))


      if MESSLEV>3 then
        writeln("************NODE REPORT*****************")
        sn:=node
        writeln("node: ",sn," Value ",nodes(sn).value, ", Variable that will be branched ", nodes(sn).branchvar)
        writeln("Fixed vars: ", nodes(sn).num_fixed, " Best INTEGER: ", Best_Value ," Best Lower Bound: ", lower_bound)
        writeln("Go to node: ", nodes(sn).fixed)
        writeln("Path at this node: ", nodes(sn).gen_path)
        writeln("Prev val: ", nodes(sn).prev_val, "Next val: ", nodes(sn).next_val)
        sn:=Select_node
        writeln("parent: ", sn, " Value ", nodes(sn).value, " L ", nodes(sn).left," R ",nodes(sn).right, " Parent: ", nodes(sn).parent)
        writeln("branching variable (parent): ", nodes(sn).branchvar)
        writeln("Prev val: ", nodes(sn).prev_val, "Next val: ", nodes(sn).next_val)
        writeln("time elapsed ", gettime, " total iter: ", Totiter,
	        " total cols: ", number_of_path)
        writeln("******************************************")
         writeln("Select_node:" , Select_node)
         writeln("Node:" , node)
        !writeln("Node LIST:" , nodes)

      end-if

    !*****************************************************
    !** Select next node using Best Bound Rule (TO DO)
    !*****************************************************
      if head=-1 or Best_Value - nodes(head).value <1.0 then
        search_done:= true
      else
        Select_node:= head
      end-if


    until search_done                           ! repeat until search is done

    end-if
 end-if                                         ! DO_BRANCHING


   send(submod, EVENT_STOP_SUBMOD,0)  ! Stop all models

  !Catch event indicating that all submodels stopped.
    wait;   dropnextevent;



  write_msg(1, "Total time: " + (gettime-StartTime) + "sec")
  write_msg(1, "Optimal objective value: " + Best_Value)


   !print_master_solution
   writeln(sol_BEST)
   writeln(sol_BEST2)
   forall(i in Flights) do
     writeln(ArcsInPath(sol_BEST2(i)))
   end-do


    forall(k in Paths) do
        write("Path ",k,",")
        forall(a in 1..getsize(ArcsInPath(k))) do
            write(ArcsInPath(k,a),",")
        end-do
        writeln("]")
    end-do


    writeln("Size of low_bound: ", getsize(Low_bound))
    forall(i in 1..getsize(Low_bound)) do
      writeln(Low_bound(i,1), " ", Low_bound(i,2))
    end-do

     !fclose(F_OUTPUT)

    declarations
      lemax: integer
      nbofnum: integer
    end-declarations


    lemax := 0
    writeln(getsize(nodes))
    forall(n in 1..getsize(nodes)-1) do
        if nodes(n).num_fixed > lemax then
            lemax := nodes(n).num_fixed
        end-if
    end-do

    writeln(lemax)
    lemax := integer(lemax)
    nbofnum := integer(2^lemax)
    writeln("Nb of NUM ICI: ", nbofnum)

   declarations
        bbtree: array( 1..nbofnum,1..lemax) of string
        pos: array(1..getsize(nodes)-1) of integer
    end-declarations

    forall(n in 1..getsize(nodes)-1) do
    writeln("Node:", n, ", ")
        pos(n) += 1
        forall(i in 1..nodes(n).num_fixed) do
        write(nodes(n).fixed(nodes(n).num_fixed-i+1))
          pos(n) += integer(nodes(n).fixed(nodes(n).num_fixed-i+1)*32/2^(i))
        end-do
    writeln("")

    bbtree(pos(n),nodes(n).num_fixed) := "Node"+n+" Value: "+nodes(n).value

    end-do
    writeln(pos)
    writeln(bbtree)

    fopen("tree.txt",F_OUTPUT)

    forall(j in 1..nbofnum) do
        forall(i in 1..lemax) do

        write(bbtree(j,i), ";")
      end-do
      writeln("")
    end-do
        write(bbtree)
    fclose(F_OUTPUT)


write(nodes)
  fopen("summary.txt",F_OUTPUT)
  writeln("Node \t Time \t Value \t BestInt \t LowerBound")
   forall(n in 0..getsize(nodes)-1) do
    writeln(n, "\t", nodes(n).parent  ,  "\t", nodes(n).value, "\t ")
    forall(i in 1..getsize(nodes(n).gen_path)) do
    writeln("\t \t Path ", nodes(n).gen_path(i), ": ", ArcsInPath(nodes(n).gen_path(i)))
    end-do
  end-do
    
 fclose(F_OUTPUT)


(! ************************************************************************
***************************************************************************
**************************     PROCEDURES     *****************************
***************************************************************************
*************************************************************************!)


!**************************************************************************
procedure do_MIP

writeln("On essaie de résoudre le MIP....")

    minimize(Master_FlowMin)
    print_status
    writeln("OF INTEGER = ", getobjval)
     if getobjval < Best_Value then
      Best_Value := getobjval
      save_best_solution
     end-if

end-procedure
!**************************************************************************



!**************************************************************************
procedure process_master_result
 (! Update dual pricing data for subproblems
    Add dual prices to upper bound calculation
 !)
 !writeln("On exécute Process master result")


  savebasis(masbasis)
  forall(a in Arcs) do
    Dual_sigma(a) := getdual(Master_Cons_ArcCap(a))
    !Dual_psi(a) := getdual(Master_MinflowCons(a))
    !lower_bound -= Dual_sigma(a) + Dual_psi(a)
  end-do

  forall(f in Flights) do
    Dual_lambda(f) := getdual(Master_Cons_Flow(f))
    !lower_bound -= Dual_lambda(f)
  end-do

  Dual_gamma := getdual(Master_Cons_MaxPath)
  !lower_bound -= Dual_gamma

   (! writeln("************************************************************")
     writeln("Beta: ",  Dual_beta)
     writeln("Lambda: ",  Dual_lambda)
     writeln("Gamma: ",  Dual_gamma)
     writeln("Sigma: ",  Dual_sigma)
     writeln("Psi  ",  Dual_psi)
    writeln("************************************************************")
!)


  initializations to "bin:shmem:Price"
    Dual_gamma
    Dual_lambda
    Dual_sigma
  end-initializations
end-procedure
!**************************************************************************

procedure solve_node
    (!  At each iteration, a shortest-path submodel is solved for each
        flight. Shortest-path solutions produce columns for the master
        problem and they are also used to calculate a Lagrangean
        upper bound. The loop is broken when no knapsack solution
        produces a column that improves the objective function
        (solved to optimality), when the master value is close
        enough to the upper bound (solved to almost optimality),
        or when the upper bound is smaller than the cutoff value
        (Best bound implies cutoff).

        Uses procedures:
            process_sub_result
            solve_master
            process_master_result
    !)

  writeln("Solve_node...")

  Best_low_bound := 0
  Niter := 0

  repeat
    Niter+=1
    send(submod, EVENT_GEN_COLS, 0)                                ! Start solving all submodels
    improve:= 0

    wait
    ev:=getnextevent
    if getclass(ev)=EVENT_INFEAS then
      write_msg(3, "Infeasible shortest path")
    end-if       !!(useful message)
    if getclass(ev)=EVENT_SOLVED then
      improve+=1
      process_sub_result
      nodes(node).gen_path += [number_of_path]
    end-if

    no_new_path := true
    if getsize(ArcsInPath(number_of_path)) = getsize(ArcsInPath(number_of_path-1)) then
        forall(i in 1..getsize(ArcsInPath(number_of_path))) do
          if ArcsInPath(number_of_path, i) <> ArcsInPath(number_of_path -1, i) then
          no_new_path := false
          end-if
        end-do
    else
     no_new_path := false
    end-if


    if no_new_path = true then
        write_msg(3, "Same path is generated")
        writeln("************************************************************")
     writeln("Lambda: ",  Dual_lambda)
     writeln("Gamma: ",  Dual_gamma)
     writeln("Sigma: ",  Dual_sigma)

    writeln("************************************************************")
    !break
    end-if


   if improve = 0  then
    write_msg(3, "Node solved to optimality")
    break
  end-if

    solve_master(Niter)
    process_master_result



 until false

 Totiter+=Niter



end-procedure

!**************************************************************************
procedure process_sub_result
    ! Add the the new column to the master problem
    !writeln("Process_sub_result")
    new_path_short := []

    initializations from "mempipe:noindex,sol"
        tot_impact_NP
        min_cap_path
        new_path_short
        obj_val
    end-initializations


    number_of_path += 1
    writeln("")
    writeln("NUMBER OF PATH: ", number_of_path, " et le path est: ", new_path_short)
    ArcsInPath(number_of_path) += new_path_short                                                    ! We store the information of which arc compose a path
    SmallCap(number_of_path) := min_cap_path

    forall(el in new_path_short) do                                                                 ! For each arc in the new path
        PathsInArc(el) += [number_of_path]                                                          ! We select this arc in ArcInPath, we get the size of this array (i.e. the number of path passing through this arc
    end-do                                                                                          ! We go one cell further (+1) and we add the new path (number of path)




    create(Master_pathSelect(number_of_path))                                                       ! Create the new variable y_j
    writeln("On ajoute une variable y et les variables x correspondantes...")
    Master_pathSelect(number_of_path) is_binary
    Master_Cons_MaxPath += Master_pathSelect(number_of_path)
    !Master_Cons_FlightPath(number_of_path) += - Master_pathSelect(number_of_path)



    forall (f in Flights) do
        ImpactPath(f, number_of_path) := tot_impact_NP(f)

        create(Master_flowPath(f, number_of_path))                                                          ! We create the new variables.
        !Master_flowPath(f, number_of_path) <= 1
        Master_flowPath(f, number_of_path) is_binary

        Master_FlowMin += ImpactPath(f, number_of_path)*Master_flowPath(f,number_of_path)                   ! We add the new variables with their coefficient in the objective function.

        forall(a in new_path_short) Master_Cons_ArcCap(a) += Master_flowPath(f,number_of_path)              ! Pour chaque arc
        forall(a in new_path_short) Master_MinflowCons(a) += Master_flowPath(f,number_of_path)


        Master_Cons_FlightPath(f, number_of_path) := Master_flowPath(f,number_of_path) - Master_pathSelect(number_of_path) <= 0
        Master_Cons_Flow(f) += Master_flowPath(f,number_of_path)

    end-do

end-procedure

!**************************************************************************


!**************************************************************************
procedure solve_master(Niter : integer)
    ! Optimize master problem



  writeln("Solve_master, check the solution (integer or not) and print the RMP solution...")

  loadprob(Master_FlowMin)
  loadbasis(masbasis)

 !file_name := "BandPrice"+Niter+".txt"
 !exportprob(EP_MIN, file_name, Master_FlowMin)

  minimize(XPRS_LIN,Master_FlowMin)

  writeln("Dans solve_master le statut du problème....: ")
  print_status

  check_solution
  if (integer_solution = true) then
    if getobjval < Best_Value then
     Best_Value := getobjval
     end-if
  end-if

   print_master_solution



end-procedure

!**************************************************************************



!**************************************************************************
procedure check_solution
 (!
    Check whether current solution is integer (integer_solution) and if we use at most H path.
    It this is the case, then the solution is a feasible solution
     We also store which path is active.
 !)
    integer_solution:=true

    if  getobjval - floor(getobjval) = 0 then
    non_integer_flight := []
    forall(f in Flights) do
    non_integer_path(f) := []
    end-do
    active_path := []



    forall(f in Flights) do
        forall(k in Paths) do
            if (getsol(Master_flowPath(f,k)) > 0) then
             active_path += [k]

                if (getsol(Master_flowPath(f,k)) < 1)then
                    integer_solution:= false
                    non_integer_flight += [f]
                    non_integer_path(f) += [k]
                end-if
            end-if
        end-do
    end-do

    else
        integer_solution := false
    end-if

    if integer_solution = false then
        writeln("Not an integer solution")
        integer_heurisitc
        !writeln("Chemins utilisés: ", active_path)
        !writeln("Chemins non entier pour les flows: ", non_integer_path)
        else
        writeln("The solution is integer")
    end-if



    !writeln("active path: ", active_path)
    !writeln("non_integer_flight: ", non_integer_flight)
    !writeln("non_integer_path: ", non_integer_path)
    !writeln("non_integer_path(3): ", non_integer_path(3))
    !writeln("non_integer_path(4): ", non_integer_path(4))

end-procedure


procedure find_non_integer
    non_integer_flight := []
    forall(f in Flights) do
    non_integer_path(f) := []
    end-do
    active_path := []



    forall(f in Flights) do
        forall(k in Paths) do
            if (getsol(Master_flowPath(f,k)) > 0) then
             active_path += [k]

                if (getsol(Master_flowPath(f,k)) < 1)then
                    integer_solution:= false
                    non_integer_flight += [f]
                    non_integer_path(f) += [k]
                end-if
            end-if
        end-do
    end-do

end-procedure

!**************************************************************************

procedure branching_variable
(!  1. Find non integer path
        1.1. Based on non integer flow x found in check_solution (array non_integer_path), find if there are some non intger path y
        1.2. If yes, add these paths in List_of_fractional
    2. Find the first divergent node
       2.1. Take the first non integer oath in List_of_fractional
       2.2. Start from the source node and select the first arc
       2.3 Check for this arc if it appears in other paths
       2.4 If no, branch on this arc
       2.5 If yes, check if there is one path going through this arc and for which y is positive. If no branch.
       2.6. If yes select the next arc on go to 2.3


       !)


writeln("Branching variable here")

find_non_integer

nodes(node).branchvar.f := non_integer_flight(1)
nodes(node).branchvar.k:= non_integer_path(non_integer_flight(1),1)
nodes(node).branchvar.size := getsize(ArcsInPath(nodes(node).branchvar.k))
nodes(node).branchvar.path := ArcsInPath(nodes(node).branchvar.k)

writeln("Branched Variable x f: ", nodes(node).branchvar.f, " path: ", nodes(node).branchvar.k)


    active_arc_bool := false
    search_div_arc := true
    already_fixed := false
    compteur := 0
    divergent_arc := []

    path_inspect := nodes(node).branchvar.k
    while (search_div_arc = true) do
        compteur := 0                                                                               ! On réinitialise le compteur d'arc
        while (compteur < getsize(ArcsInPath(path_inspect))) do                                    ! Tant qu'on atteind pas le dernier arc du chemin
            compteur += 1                                                                           ! On passe à l'arc suivant
            arc_inspect := ArcsInPath(path_inspect,compteur)                                        ! On initiliase l'arc qui est inspecté
            active_arc_bool := false

            if getsize(PathsInArc(arc_inspect)) > 1 then
             forall(path in PathsInArc(arc_inspect)) do
                if path <> path_inspect then
                    if getsol(Master_pathSelect(path)) > 0 then
                        writeln("Il y a un chemin actif qui passe par l'arc: ", arc_inspect)
                        active_arc_bool := true
                        break 1
                    end-if
                end-if
             end-do
            end-if
            if active_arc_bool = false then
                     already_fixed := false
                     forall(i in 1..Nfixed) do
                      if fixed_vars(i).to_zero = true then
                        if arc_inspect = fixed_vars(i).var.a then
                            writeln("Cet arc a déjà été fixée à 0")
                            already_fixed := true
                            break
                        end-if
                      end-if
                     end-do
            end-if
        if (already_fixed = false and active_arc_bool = false) then                                                               ! On a trouve l'arc divergent
        divergent_arc += [arc_inspect]

        !search_div_arc := false
        !break 2
        end-if

       end-do
       writeln("Il n'y pas/plus d'arc divergent")
       search_div_arc := false
    end-do

    writeln("Liste des arcs divergent: ",divergent_arc)


    smaller := 100.00

    if getsize(divergent_arc) > 0 then
        forall(arc in divergent_arc) do
          if ArcCap(arc) <=  smaller then
            smaller := ArcCap(arc)
            arc_inspect := arc
          end-if
        end-do
     nodes(node).branchvar.a := arc_inspect
    else
     nodes(node).branchvar.a := arc_inspect
    end-if


    !nodes(node).branchvar.a := arc_inspect
    writeln("Sur le noeud: ", node, "  on fixe l'arc: ", nodes(node).branchvar.a)
    writeln("Branched Variable x f: ", nodes(node).branchvar.f, " path: ", nodes(node).branchvar.k, " arc: ", nodes(node).branchvar.a)


end-procedure
!**************************************************************************



!**************************************************************************

procedure variable_branching_reset
 (! Determine all compact formulation variables that need to be fixed
    at the current node. Right children are fixed to zero and left
    children are fixed to one.
     uses procedure:
     fixvar
 !)


  branchvar:= nodes(Select_node).branchvar                          ! Select_node est le noeud ACTIF

 !Fix variables
  if nodes(Select_node).left=-1 then           !Left node           ! Si le left node n'a pas encore été attribué (-1) alors:
    fixvar(branchvar,false)                                          ! On utilise la function fixvar pour fixer la variable qui doit être fixée pour ce noeud (branchvar) qui a été décidé dans la fonction "branching_variable)
    nodes(Select_node).left:=node                                   ! Si le left n'a pas été attribué, c'est qu'on vient de créer un nouveau noeud et donc le Parent node est ainsi le noeud actif,
                                                                    ! c'est à dire "Select_node" et on fixe le left node du parent comme étant le nouveau noeud "node".

  else                                         !Right node          ! Si le left node a été déjà été créé, alors on créer le right node, sur le noeud actif
    fixvar(branchvar,true)
    nodes(Select_node).right:=node                                  ! Idem
    !!and take selected node out of queue                           ! Si on a relié le noeud actif à son left ET à son right, le noeud actif, est "résolu" et sort de la liste de noeud que l'on peut sélectionner.
    head:=nodes(Select_node).next_val                               ! La prochaine valeur dans la liste des noeuds actif et la "next_val" de select node
    nodes(head).prev_val:=-1                                        ! On ne peut plus atteindre "select_node"
  end-if

!Fix variable for all the parent nodes in the tree.
  visit:=Select_node
  while (nodes(visit).parent<>-1) do
    parent:=nodes(visit).parent
    branchvar:=nodes(parent).branchvar
    if visit=nodes(parent).left then
      fixvar(branchvar,false)
    else
      fixvar(branchvar,true)

    end-if
    visit:=parent
  end-do




end-procedure
!**************************************************************************



!**************************************************************************
procedure fixvar(branchvar: branchvartype, to_zero: boolean)
 (! Build array fixed_vars and set fixedcolumns with compact and disaggregated
  formulation variables to be fixed. Array fixed_vars is to be later passed to
  knapsack subproblems. The set fixedcolumns is to be used to create consfix
  constraints. Implementation avoids duplicating consfix constraints by using
  function encode to place unique pairs m-k in set fixedcolumns.
 !)

  Nfixed+=1
  fixed_vars(Nfixed).var:=branchvar

  case to_zero of
    true: do                                    !Fix to zero
      fixed_vars(Nfixed).to_zero:=true
      nodes(node).fixed += [0]
    end-do

    false: do                                   !Fix to one
      fixed_vars(Nfixed).to_zero:=false
       nodes(node).fixed += [1]
      end-do
  end-case
end-procedure



!**************************************************************************
procedure save_best_solution

    forall(f in Flights) do
        sol_BEST2(f) := 0
        forall(k in Paths) do
            sol_BEST(f,k) := 0
            sol_BEST(f,k) := getsol(Master_flowPath(f,k))
            if getsol(Master_flowPath(f,k)) = 1 then
            sol_BEST2(f) := k
            end-if
        end-do
    end-do

end-procedure
!**************************************************************************

!**************************************************************************
procedure save_best_solution2

   forall(f in Flights) do
        sol_BEST2(f) := 0
        sol_BEST2(f) := compt3(f,1)
        end-do


    writeln("")

end-procedure
!**************************************************************************







!**************************************************************************
procedure print_status
        ! Print the status of the current problem
 declarations
  status: string
 end-declarations

 case getprobstat of
  XPRS_OPT: status:="Optimum found"
  XPRS_UNF: status:="Unfinished"
  XPRS_INF: status:="Infeasible"
  XPRS_UNB: status:="Unbounded"
  XPRS_OTH: status:="Failed"
  else status:="???"
 end-case

 writeln("Problem status: ", status)
end-procedure
!**************************************************************************


!**************************************************************************
procedure print_master_solution

    writeln("  ***   **  *** SOLUTION ***  **   *** ")
    writeln("Current best integer solution: ", Best_Value)
    writeln("Objective value: ", getobjval)


    write("Variable y: ")
    forall(k in Paths) do
       write( getsol(Master_pathSelect(k)), ", ")
    end-do

    writeln(" ")
     write("Variable x: ")
    forall(l in Flights) do
        forall(k in Paths) do
            write( getsol(Master_flowPath(l,k)), ", ")
        end-do
    end-do

    writeln(" ")
     forall(f in Flights) do
        write("L'avion ",f, " prend le(s) chemin(s):[ ")
        forall(k in Paths) do
          if  getsol(Master_flowPath(f,k)) > 0 then
          write(k, " (", getsol(Master_flowPath(f,k)), ") " )
          end-if
        end-do
        writeln("]")
    end-do

    writeln("")
    !writeln("Chemins utilisés: ", active_path)
    !writeln("Chemins non entier pour les flows: ", non_integer_path)

    writeln(" ")
    write("Liste des arcs positifs: ")
    forall (a in Arcs) do
      if getsol(Master_arcSelect(a)) > 0 then
       write(" ", a, " (", getsol(Master_arcSelect(a)), ") ")
       end-if
    end-do
    writeln("")
    writeln("  ***     *** ****** ***     *** ")


end-procedure
!***************************************************************************


!***************************************************************************
procedure integer_heurisitc
 ! This procedure seeks to get an integer solution from a non integer solution

writeln("")
writeln("############   On cherche une solution entière.... ##########")


forall (f in Flights) do
  compt2(f) := 0
  compt3(f) := []
end-do

    !writeln(" ")
     forall(f in Flights) do
       ! write("L'avion ",f, " prend le(s) chemin(s):[ ")
        forall(k in Paths) do
          if  getsol(Master_flowPath(f,k)) > 0 then
          compt2(f) += 1
        !  write(k, " (", getsol(Master_flowPath(f,k)), ") " )
          compt3(f) += [k]
          end-if
        end-do
        !writeln("]")
    end-do


!writeln("Compt2: ", compt2)
!writeln("Compt3: ", compt3)

do_integer_flow
check_num_path

if Tot_num <= 4 then
 check_possible_sol
    if possible_sol = true then
        writeln("Une solution entière a été trouvée...")
        writeln("FO integer value: ", int_FO)
        if int_FO < Best_Value then
            Best_Value:= int_FO
            writeln("Et celle-ci est meilleur que l'actuelle... On update Best_Value")
            writeln(compt3)
            save_best_solution2
        end-if
    else
     writeln("... pas de solution entière réalisable à cause des capacités")
    end-if
else
   writeln("... pas de solution entière, il y a trop de chemins utilisés")
end-if

writeln(" ###########################################################")
writeln("")


end-procedure
!***************************************************************************
procedure do_integer_flow


most_used := 0
most_used_value := 1.0

forall(f in Flights) do
 most_used := 0
 most_used_value := 1.0
  if compt2(f) > 1 then
    forall(i in compt3(f)) do
      if (getsol(Master_flowPath(f,i)) < most_used_value) then
        most_used := i
        most_used_value := getsol(Master_flowPath(f,i))
      end-if
    end-do
    compt3(f) := [most_used]
  end-if
end-do


end-procedure

!**************************************************************************
procedure check_num_path

Tot_num := 0
forall(i in Paths) do
  compt4(i) := 0
end-do


forall(i in 1..getsize(compt3)) do
  compt4(compt3(i,1)) += 1
end-do

forall(i in Paths) do
  if compt4(i) > 0 then
    Tot_num += 1
  end-if
end-do

writeln("Il y a ", Tot_num, " chemins entiers")

end-procedure

!**************************************************************************

procedure check_possible_sol

int_FO := 0.0
possible_sol := true
forall(arc in Arcs) do
  arc_use(arc) := 0
end-do


forall(i in 1..getsize(compt3)) do
    forall(arc in ArcsInPath(compt3(i,1))) do
        arc_use(arc) += 1
        int_FO += ArcWeight(i,arc)
    end-do
end-do


forall(arc in Arcs) do
  if arc_use(arc) > ArcCap(arc) then
    possible_sol := false
  end-if
end-do

end-procedure




!**************************************************************************
 procedure write_msg(msglevel:integer, msg:string)
  if msglevel<= MESSLEV then
    writeln(msg)
  end-if
end-procedure









end-model